# 学习笔记

## 第一步总结
为了方便文件管理，把 parser 单独拆到文件中
parser 接受 HTML 文本作为参数，返回一个 DOM 树

## 第二步总结
用 FSM 来实现 HTML 的分析
再 HTML 标准中，已经规定了 HTML 的 80 中状态
Toy-Browser 只挑选一部分状态完成一个简易版本

## 第三步总结
主要的标签有：开始标签，结束标签，自封闭标签
这一步暂时忽略属性

## 第四步总结
状态机中除了状态迁移还要加入业务逻辑
标签的结束状态提交标签token 

## 第五步处理属性总结
属性值分为单引号、双引号、无引号三种写法，因此需要较多的状态处理
处理属性的方式跟标签类似
属性结束时，我们把属性加到标签token上
## 第六步处理属性总结
从标签构建DOM书的基本技巧是使用占
遇到开始标签时创建元素并入栈，遇到结束标签时出站
自封闭节点可视为入栈后立刻出站
任何元素的父元素是它入栈前的栈顶

## 第七步总结
文本节点与自封闭标签处理类似
多个文本节点需要合并

# 构建带 css 的 dom 树
## 第一步
遇到 style 标签的时候，把 css 规则保存起来
这里我们调用 CSS Parse 来分析 css规则
这里我们必须要仔细研究此库分析css规则的格式

## 第二步
创建一个元素后立即计算css
理论上当我们分析一个元素时，所有的css规则已经收集完毕
在真是的的浏览器中，可能遇到卸载body 的style标签，需要重新css计算的情况，我们忽略

## 第三步
在 compouteCSS 函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
我们从上一步的tack，可以获取所有的父元素
因为我们首先获取的当前元素，所以我们获得的父元素和元素匹配的顺序是从内向外

## 第四步
选择器也要从当前元素向外排列
复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列  

## 第五步
根据选择器的类型和元素属性，计算是否与当前元素匹配
这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器

## 第六步
一旦选择器匹配，就应用选择器到元素上，形成 computedStyle 

## 第六步
css 规则根据 specificity 和 后来有限规则覆盖
specificity 是个思源组，越左边权重越高
一个 css 规则的 specificity 根据包含的简单选择器相加而成