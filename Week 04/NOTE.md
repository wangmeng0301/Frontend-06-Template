 # 学习笔记

 ## 字符串分析算法
  字典树：大量高重复字符串的存储与分析
  KMP：用于模式匹配（查一个长字符串里有没有另一个短字符串）
  Wildcard：带通配符的字符串模式
  正则：字符串通用模式匹配
  状态机：通用的字符串分析
  LL、LR：字符串多层级结构分析

### 字典树
  字典树又称前缀树或单词查找树，通过将一些事先存在的字符串保存在trie树中，实现字符串检索、前缀匹配和词频统计等功能。是一种专门用来处理字符串匹配的树形结构。
  Trie树的本质是利用字符串之间公共前缀，将重复的前缀合并在一起
  Trie 树是一个多叉树，借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针
  构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。
  构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。
  #### 数据结构
  ``` js
  trie =
      {
          h: {
              e: {
                  l: {
                      l: {
                          o: {
                              $: 10,
                          },
                      },
                      p: {
                          $: 1,
                      },
                  },
                  $: 5,
              },
              i: {
                  $: 3,
              },
          },
      }
  ```

### kmp
  在字符串的匹配过程中，当模式串和主串不匹配时，最简单粗暴的方法就是模式串从头开始匹配，KMP算法就是根据模式串自身的模式特点，在匹配时遇到不匹配的情况不用每次都从头开始匹配，而是尽可能多地从模式串中间再次开始。

  第一步 找 pattern 中是不是有自重复的内容
  ``` js
  {
    let i = 1; j = 0;
    while(i < pattern.length) {
      if (pattern[i] === pattern[j]) { 
        ++i, ++j;
        table[i] = j;
      } else {
        if (j > 0) {
          j = table[j];
        } else {
          ++i;
        }
      }
    }
  }
  ```
  第二部 匹配 source 和 pattern 的内容，根据第一步自重复的内容，每次匹配失败不会从头开始，而是根据自重复构建的 table 找到跳转到的位置开始匹配

  ``` js
  {
    let i = 0; j = 0;
      while(i < source.length) {
        debugger;
        if (source[i] === pattern[j]) { 
          ++i, ++j;
        } else {
          if (j > 0) {
            j = table[j];
          } else {
            ++i;
          }
        }
        if (j === pattern.length)
          return true
      }
    return false;
  }
  ```

### Wildcard
  在KMP的基础上加上了通配符
  两种通配符 * ？ 1. ? 代表 可以充当任意字符 等价于 [\s\S]. 2. * 代表充当长度大于等于0的任意字符串
  前面的*: 尽量匹配少
  后面的*: 尽量匹配多